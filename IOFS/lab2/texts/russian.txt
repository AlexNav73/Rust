Rust — мультипарадигмальный компилируемый язык программирования общего назначения, разрабатываемый Mozilla Research, поддерживающий функциональное программирование, модель акторов, процедурное программирование, объектно-ориентированное программирование. Rust?— это системный язык программирования, внимание которого сосредоточено на трёх задачах: безопасность, скорость и параллелизм. Он сопоставим по скорости и возможностям с C++, однако, даёт большую безопасность при работе с памятью, что обеспечивается механизмами ограничения. Rust также направлен на достижение «абстракции с нулевой стоимостью». После нескольких лет активной разработки первая стабильная версия (1.0) вышла 15 мая 2015 года, после чего новые версии выходят раз в 6 недель. Программы, написанные на ранних стабильных версиях языка будут собираться и на более новых стабильных версиях.
Работа над языком была начата Грэйдоном Хором в 2006 году, в 2009 к разработке подключилась Mozilla, и в 2010 году язык был официально представлен на Mozilla Summit 2010. Также в 2010 году разработка языка была переведена с использования компилятора, написанного на OCaml, на компилятор, написанный на Rust, с использованием LLVM в качестве back-end. В следующем году он успешно скомпилировал сам себя. Январь 2012 г.: выпуск альфа-версии (0.1) компилятора Rust. Апрель 2013 г.: выпуск версии 0.6. Одновременно с этим, Mozilla объявила о присоединении Samsung к проекту Servo — браузерному движку нового поколения, при активном участии которой код движка Servo был портирован на ARM архитектуру. Январь 2015 г.: выпуск версии Rust 1.0 Alpha, было стабилизировано ядро языка и большая часть стандартных библиотек; переработана и улучшена система макросов; после долгих обсуждений переименованы типы integer: int и uint стали isize и usize; убрана недоделанная система «зелёных» потоков. Апрель 2015 г.: выпуск версии Rust 1.0 Beta, язык стабилизирован, до финального релиза возможны небольшие правки в API. Май 2015 г.: выпуск версии Rust 1.0. Программные интерфейсы и возможности языка подверглись значительной ревизии, после которой по умолчанию оставлены только полностью готовые к применению возможности, реализация которых не будет изменяться в дальнейшем. Все остальные функции переведены в разряд экспериментальных и вынесены из поставки по умолчанию. Язык Rust имеет встроенные простые типы.
Целочисленные типы, имеющие размер указателя на данной платформе, Булев, Символ, представляющий символ Unicode,
Числа с плавающей точкой,Массив,Срез массива, Ссылка на непрерывную часть массива, фактически содержит ссылку на первый элемент среза и на длину среза, Строки, Тип String, владеющий содержимым, и строковый срез str, гарантированно содержащие валидную UTF-8 строку, Кортеж. Подобно структуре, содержит произвольное количество разнотипных полей, но поля безымянны, обращение к полям возможно по индексу. Кортежи - безымянные типы: кортежи с одинаковым количеством и типами полей являются совместимыми по типу. С помощью ключевого слова type можно задать псевдоним, который, однако, не задает нового типа, Функция Объекты-функции имеют тип, определяемый их сигнатурой, т. е. параметрами и возвращаемым значением. Возможности объявления пользовательских типов: Структуры в языке Rust практически не отличаются от структурных типов других языков. Структура объявляет именованные поля данных (методы могут быть объявлены отдельно с помощью ключевого слова impl). Согласно теории типов являются типом-произведением, Перечисление Аналогично объединению C и C++, поскольку разделяют одну и ту же память для разных типов данных, но запоминают сохраненный тип и не позволяют обращаться к этим данным как к другому типу. По классификации теории типов являются типом-суммой. Обычное перечисление является вырожденным случаем типа-суммы, Кортеж-структура гибридный тип, обладающий свойствами кортежа и структуры: именованный тип с безымянными полями. В Rust реализована «умная» модель памяти, поддерживающая эффективные структуры данных и безопасные шаблоны параллельного выполнения, а также полностью запрещающая некорректный доступ к памяти, который обычно является источником критических ошибок сегментации в других языках программирования. Отсутствие null-указателей, контроль за использованием неинициализированных и деинициализированных переменных; невозможность совместного использования разделяемых состояний несколькими задачами; статический анализ времени жизни указателей; проверка на выход за пределы массива (автоматически и всегда). Модель памяти Rust можно охарактеризовать следующими терминами. Move-семантика По умолчанию объект «переносится» новому владельцу при присваивании. При этом происходит простое побайтовое копирование (в случае оптимизации - не происходит и этого), старая связка при этом становится недействительной. Заимствования с возможностью изменения заимствованного объекта и без таковой Лексически и семантически очень схожи со ссылками, но имеют специфику: заимствование объекта сходно семантике «Либо много читателей, либо один писатель» — объект можно передать в заимствование либо однократно с возможностью изменения объекта, либо многократно без таковой; заимствования можно перезаимствовать другому заемщику. В отличие от настоящей семантики «Либо много читателей, либо один писатель», применяется не в контексте синхронизации потоков, а универсально. Контроль корректности заимствований происходит во время компиляции и не порождает дополнительного исполнимого кода (принцип zero-cost abstractions). Компилятором контролируется также соотношение времен жизни заимствований и самого объекта — заимствования не могут жить (выходить за пределы области видимости) заимствованного объекта. Заимствования работают с любыми данными независимо от их размещения (стек, локальная или обменная куча, другие специальные расположения). Следует различать независимые понятия — изменяемость собственно заимствования и изменяемость заимствованного объекта. Упаковка Простой умный указатель, владеющий объектом в куче. Уничтожает объект и освобождает память при выходе из области видимости. Ячейка Реализует изменяемость содержимого при неизменяемости самой ячейки. Указатели со счётчиком ссылоки с атомарным счётчиком ссылок Умные указатели с подсчетом ссылок, уничтожающие объект и освобождающие память при обнулении счетчика. Arc реализует потокобезопасность для счетчика ссылок (но не для самого объекта). Rc и Arc контролируют неизменяемый объект, поэтому типичное их использование выглядит как в однопоточной программе и Arc<Mutex<T>> в многопоточной. Сырые указатели неизменяемые и изменяемые Указатели без гарантии безопасности. Настоятельно не рекомендуется их использовать. Связывания неизменяемы по умолчанию, а чтобы объявить переменную изменяемой, необходимо ключевое слово mut. Синтаксис Rust похож на Си и C++ с блоками кода, разделёнными фигурными скобками, и такими управляющими ключевыми словами, как if, else, while, и for; комментарии также пишутся в С-формате; имена модулей разделяются двумя символами двоеточия. Ключевое слово let определяет локальную переменную. Rust поддерживает макроопределения — средства подстановки с использованием регулярных выражений, выполняющиеся во время этапа подготовки к компиляции, более развитые и безопасные, чем в Си. Макроопределения (макрокоманды) — это определяемые пользователем простые расширения синтаксиса, выполняемые с помощью команды macro_rules! Макрокоманды определяются в том же стиле, что и конструкция сравнения с образцом. Признак макроса - восклицательный знак в конце имени. В Rust объектная система основана на типажах (traits) и структурах данных. Типажи определяют типы, а также соответствующие методы и реализации. Типаж может содержать реализации методов, принимаемые по умолчанию. Реализация типажей для данной структуры, а также реализация собственных методов структуры обозначается ключевым словом impl. Язык содержит несколько десятков предопределенных типажей, большая часть которых используется для перегрузки операторов, а некоторые имеют специальное значение. Rust поддерживает обобщённые типы. Помимо функций, обобщёнными в Rust могут быть комплексные типы данных, структуры и перечисления. Компилятор Rust компилирует обобщённые функции весьма эффективно, применяя к ним мономорфизацию (генерация отдельной копии каждой обобщённой функции непосредственно в каждой точке её вызова). Таким образом, копия может быть адаптирована под конкретные типы аргументов, а следовательно, и оптимизирована для этих типов. В этом отношении обобщённые функции Rust сравнимы по производительности с шаблонами (templates) языка C++. В более ранних версиях языка поддерживались легковесные потоки, но потом от них отказались в пользу нативных потоков операционной системы. При этом рекомендуемым методом обмена данными между потоками является отправка сообщений, а не использование общей памяти. Для достижения высокой производительности возможно отправлять данные не через копирование, а используя собственные указатели. Они гарантируют только одного владельца.
